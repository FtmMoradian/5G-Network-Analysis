# -*- coding: utf-8 -*-
"""5G Network Analysis .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ca1Ryqsq8Ht225Sfqb3pSRiFDNo7Ugyt

Import Libraries
"""

import pandas as pd
import numpy as np
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
warnings.filterwarnings('ignore')
import pandas as pd
import numpy as np
import warnings
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
warnings.filterwarnings('ignore')
from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder,OneHotEncoder
label_encoder = LabelEncoder()

"""Load DataSet"""

data = pd.read_csv('/content/drive/MyDrive/DataScienceProject/5G Time Series/Data Set/Quality of Service 5G.csv')

data.columns

"""Display DataSet"""

data.head()

"""Summary"""

data.describe().T

data.info()

data.isnull().sum()

data.size

data.shape

data['User_ID'].nunique()

"""Unique Values"""

data['Application_Type'].unique()

data['Application_Type'].nunique()

data['Signal_Strength'].unique()

data['Signal_Strength'].nunique()

data['Latency'].unique()

data['Latency'].nunique()

data['Resource_Allocation'].unique()

"""Regex Cleaning"""

data['Signal_Strength'] = data['Signal_Strength'].str.extract('(\d+)').astype(int)
data['Latency'] = data['Latency'].str.extract('(\d+)').astype(int)
data['Resource_Allocation'] = data['Resource_Allocation'].str.extract('(\d+)').astype(int)

data.head()

data[['Size','Unit']] = data.Required_Bandwidth.str.split(' ', expand=True)

data['Size'] = data.Size.astype(float)

data.Unit.replace({'Mbps':1024, 'Kbps':1}, inplace=True)

data.head()

data['Required_Bandwidth_Size_in_KB'] = data.Size * data.Unit

data.head(1)

data.drop(columns='Size',inplace=True)
data.drop(columns='Unit',inplace=True)

data.head(1)

"""Converting Allocated_Bandwidth Unit from Mbps to Kbps"""

data[['Size1','Unit1']] = data.Allocated_Bandwidth.str.split(' ', expand=True)

data['Size1'] = data.Size1.astype(float)

data.Unit1.replace({'Mbps':1024, 'Kbps':1}, inplace=True)

data['Allocated_Bandwidth_Size_in_KB'] = data.Size1 * data.Unit1

data.head(1)

data.drop(columns='Size1',inplace=True)
data.drop(columns='Unit1',inplace=True)

data.head(1)

data.drop(columns='Allocated_Bandwidth',inplace=True)
data.drop(columns='Required_Bandwidth',inplace=True)

data.head(1)

data.rename(columns = {'Required_Bandwidth_Size_in_KB':'Required_Bandwidth'},inplace=True)

data.rename(columns = {'Allocated_Bandwidth_Size_in_KB':'Allocated_Bandwidth'},inplace=True)

data.head(1)

""" Online Gaming with least avg bandwidth requirement"""

new_data_Online_Gaming = data[data['Application_Type']=='Online_Gaming']

sorted_Online_Gaming = new_data_Online_Gaming.sort_values(by='Required_Bandwidth')

sorted_Online_Gaming.tail(1)

data['Timestamp'].nunique()

"""User with high Required_Bandwidth User with high signal strength"""

data.Signal_Strength.max()

data.query("Signal_Strength == 123")

data.Required_Bandwidth.max()

data.query("Required_Bandwidth == 14848")

"""User with high Allocated_Bandwidth"""

data.Allocated_Bandwidth.max()

data.query("Allocated_Bandwidth == 16179.2")

"""User with high Latency"""

data.Latency.max()

data.query("Latency == 110")

""" Average of signal strength on diffrent application"""

app_signsl_strength = data.groupby(['Application_Type'])['Signal_Strength'].mean()

"""maximum average of signal strength on diffrent application"""

app_signsl_strength.nlargest()

"""Minimum average of signal strength on diffrent application"""

app_signsl_strength.nsmallest()

"""Average of latency on diffrent application"""

app_Latency = data.groupby(['Application_Type'])['Latency'].mean()

"""maximum average of latency on diffrent application"""

app_Latency.nlargest()

""" minimum average of latency on diffrent application"""

app_Latency.nsmallest()

data.groupby(['Application_Type'])['Latency'].mean()

"""Average of resource_Allocation on diffrent application"""

app_Resource_Allocation = data.groupby(['Application_Type'])['Resource_Allocation'].mean()

"""maximum average of latency on diffrent application"""

app_Resource_Allocation.nlargest()

"""minimum average of latency on diffrent application"""

app_Resource_Allocation.nsmallest()

"""Average of resource_Allocation on diffrent Timestamp"""

timestamp_Resource = data.groupby(['Timestamp'])['Resource_Allocation'].mean()

timestamp_Resource.nlargest()

timestamp_Resource.nsmallest()

timestamp_Latency = data.groupby(['Timestamp'])['Latency'].mean()

timestamp_Latency

""" **VISUALISATION**"""

plt.figure(figsize=(12, 6))
sns.boxplot(x='Application_Type', y='Latency', data=data)
plt.title('Latency by Application Type')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(12, 6))
sns.boxplot(x='Application_Type', y='Signal_Strength', data=data)
plt.title('Signal Strength by Application Type')
plt.xticks(rotation=45)
plt.show()

data_sorted = data.sort_values(by='Required_Bandwidth')

plt.figure(figsize=(16, 6))
sns.barplot(data=data_sorted, x= 'Application_Type', y = 'Required_Bandwidth')
plt.show()

sns.countplot(x=data['Resource_Allocation'])

plt.figure(figsize=(10, 6))
sns.countplot(data=data, x='Application_Type')
plt.title('Distribution of Application Types')
plt.xticks(rotation=45)
plt.xlabel('Application Type')
plt.ylabel('Count')
plt.show()

plt.figure(figsize=(10, 6))
sns.histplot(data=data, x='Resource_Allocation', bins=10 ,kde=True)
plt.title('Distribution of Resource Allocation')
plt.xlabel('Resource Allocation (%)')
plt.ylabel('Count')
plt.show()

plt.figure(figsize=(6,6))
plt.title('Resource_Allocation')
plt.xlabel('Range')
plt.ylabel('Count')
plt.xticks(rotation = 45)
plt.yticks(rotation = 45)
sns.histplot(data=data, x='Resource_Allocation')
plt.show()

app_name  =data.Application_Type.value_counts().index
lat_val = data.Latency.value_counts().values
plt.pie(lat_val[:7],labels = app_name[:7],autopct='%1.f%%');

data.head(1)

data.info()

data.Timestamp.unique()

ts1=data.query("Timestamp =='9/3/2023 10:00'")
ts1.head()

ts1pie = ts1.groupby(['Application_Type'])['Application_Type'].count().reset_index(name='type_count')
ts1pie

ts1pie.type_count

plt.figure(figsize=(12,8))
plt.pie(ts1pie.type_count.values,labels = ts1pie.Application_Type.values,autopct='%1.2f%%');

plt.figure(figsize=(10, 12))
sns.histplot(data=data, x='Signal_Strength', bins=20, kde=True)
plt.title('Distribution of Signal Strength')
plt.xlabel('Signal Strength')
plt.ylabel('Frequency')
plt.show()

application_counts = data['Application_Type'].value_counts()
application_counts

plt.figure(figsize=(10, 6))
sns.barplot(x=application_counts.index, y=application_counts.values, palette="viridis")
plt.title('Most Commonly Used Application Types')
plt.xlabel('Application Type')
plt.ylabel('Count')
plt.xticks(rotation=90)
plt.show()

plt.figure(figsize=(8, 6))
sns.scatterplot(data=data, x='Signal_Strength', y='Allocated_Bandwidth',)
plt.title('Correlation Between Signal Strength and Allocated Bandwidth')
plt.xlabel('Signal Strength')
plt.ylabel('Allocated Bandwidth')
plt.grid(True)
plt.show()

correlation_coefficient = data['Signal_Strength'].corr(data['Allocated_Bandwidth'])
print(f"Correlation Coefficient: {correlation_coefficient}")

plt.figure(figsize=(8, 6))
sns.histplot(data=data, x='Resource_Allocation', bins=20, kde=True)
plt.title('Distribution of Resource Allocation Among Users')
plt.xlabel('Resource Allocation')
plt.ylabel('Frequency')
plt.show()

plt.figure(figsize=(8, 6))
sns.scatterplot(data=data, x='Required_Bandwidth', y='Allocated_Bandwidth')
plt.title('Relationship Between Allocated Bandwidth and Required Bandwidth')
plt.xlabel('Required Bandwidth')
plt.ylabel('Allocated Bandwidth')
plt.grid(True)
plt.show()

correlation_coefficient = data['Allocated_Bandwidth'].corr(data['Required_Bandwidth'])
print(f"Correlation Coefficient: {correlation_coefficient}")

"""Matplotlib"""

data.head()

data.Signal_Strength.plot(kind = 'line', color = 'g',label = 'Signal_Strength',linewidth=1,alpha = 0.5,grid = True,linestyle = ':')
data.Latency.plot(color = 'r',label = 'Latency',linewidth=1, alpha = 0.5,grid = True,linestyle = '-.')
plt.legend(loc='upper right')
plt.xlabel('x axis')
plt.ylabel('y axis')
plt.title('Line Plot')
plt.show()

data.plot(kind='scatter', x='Signal_Strength', y='Latency',alpha = 0.5,color = 'red')
plt.xlabel('Signal Strength')
plt.ylabel('Latency')
plt.title('Signal Strength vs Latency Scatter Plot')

data.Signal_Strength.plot(kind = 'hist',bins = 50,figsize = (8,8))
plt.show()

x = data['Signal_Strength']>20
data[x]

data[np.logical_and(data['Signal_Strength']>20, data['Latency']<10 )]

i = 0
while i != 5 :
    print('i is: ',i)
    i +=1
print(i,' is equal to 5')

lis = [1,2,3,4,5]
for i in lis:
    print('i is: ',i)
print('')

for index, value in enumerate(lis):
    print(index," : ",value)
print('')

dictionary = {'spain':'madrid','france':'paris'}
for key,value in dictionary.items():
    print(key," : ",value)
print('')

for index,value in data[['Signal_Strength']][0:10].iterrows():
    print(index," : ",value)

x = 2
def f():
    x = 3
    return x
print(x)
print(f())

""" Signal scope"""

x = 5
def f():
    y = 2*x
    return y
print(f())

def square():
    """ return square of value """
    def add():
        """ add two local variable """
        x = 2
        y = 3
        z = x + y
        return z
    return add()**2
print(square())

square = lambda x: x**2
print(square(4))
tot = lambda x,y,z: x+y+z
print(tot(1,2,3))

name = "AMCT 2023-2024"
it = iter(name)
print(next(it))
print(next(it))
print(next(it))
print(*it)

num1 = [1,2,3]
num2 = [i + 1 for i in num1]
print(num2)

num1 = [5,10,15]
num2 = [i**2 if i == 10 else i-5 if i < 7 else i+5 for i in num1]
print(num2)

threshold = sum(data.Signal_Strength)/len(data.Signal_Strength)
data["Signal Strength Level"] = ["high" if i > threshold else "low" for i in data.Signal_Strength]

data.head()

data.loc[:10,["Signal Strength Level","Signal_Strength"]]

sns.barplot(x="Resource_Allocation", y="Signal Strength Level", hue="Application_Type", data=data);

sns.pointplot(x="Resource_Allocation", y="Signal Strength Level", hue="Application_Type", data=data);

data_new = data
data_new['Application_Type'] = label_encoder.fit_transform(data_new['Application_Type'])

data_new.head()

data_new['Signal Strength Level'] = label_encoder.fit_transform(data_new['Signal Strength Level'])
data_new['Timestamp'] = label_encoder.fit_transform(data_new['Timestamp'])
data_new['User_ID'] = label_encoder.fit_transform(data_new['User_ID'])

data_new.head()

enc = OneHotEncoder(drop='first')
data_new2 = data
enc_app = pd.DataFrame(enc.fit_transform(data[['Application_Type']]).toarray())
data_new2 = data_new2.join(enc_app)

data_new2.head()

data_new2.drop(data_new2.iloc[:, 9:], inplace=True, axis=1)

"""Split Train and Test"""

from sklearn.model_selection import train_test_split

X_all = data_new2.drop(['Signal_Strength', 'Signal Strength Level'], axis=1)
y_all = data_new2['Signal Strength Level']

num_test = 0.20
X_train, X_test, y_train, y_test = train_test_split(X_all, y_all, test_size=num_test, random_state=23)

"""Random Forest Classifier"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import make_scorer, accuracy_score
from sklearn.model_selection import GridSearchCV

clf = RandomForestClassifier()

parameters = {'n_estimators': [4, 6, 9],
              'max_features': ['log2', 'sqrt','auto'],
              'criterion': ['entropy', 'gini'],
              'max_depth': [2, 3, 5, 10],
              'min_samples_split': [2, 3, 5],
              'min_samples_leaf': [1,5,8]
             }

acc_scorer = make_scorer(accuracy_score)

grid_obj = GridSearchCV(clf, parameters, scoring=acc_scorer)
grid_obj = grid_obj.fit(X_train, y_train)

clf = grid_obj.best_estimator_

clf.fit(X_train, y_train)

predictions = clf.predict(X_test)
print(accuracy_score(y_test, predictions))

"""K-Fold Validation"""

from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold

k = 5
kf = KFold(n_splits=k, random_state=None)

result = cross_val_score(clf , X_train, y_train, cv = kf)

print("Avg accuracy: {}".format(result.mean()))

ids = X_test['User_ID']
output = pd.DataFrame({ 'User_ID' : ids, 'Signal Strength Level': predictions })
output.head()

